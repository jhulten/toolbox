name: Check APT Package Updates

on:
  schedule:
    # Run every Monday at 9:00 AM UTC
    - cron: '0 9 * * 1'
  workflow_dispatch: # Allow manual trigger

permissions:
  contents: read
  issues: write

jobs:
  check-updates:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check for package updates
        id: check
        run: |
          set -e
          
          # Function to check package updates in a Dockerfile
          check_dockerfile() {
            local dockerfile=$1
            local base_image=$2
            local results=""
            
            echo "Checking $dockerfile..."
            
            # Extract pinned packages (format: package=version)
            packages=$(grep -oP '(?<=\s)[a-z0-9\-]+=[0-9][a-zA-Z0-9.:+~-]*' "$dockerfile" || true)
            
            if [ -z "$packages" ]; then
              echo "No pinned packages found in $dockerfile"
              return
            fi
            
            # Collect package names and their current (pinned) versions
            local pkg_names=()
            local current_versions=()
            
            for pkg_version in $packages; do
              pkg_names+=("$(echo "$pkg_version" | cut -d= -f1)")
              current_versions+=("$(echo "$pkg_version" | cut -d= -f2)")
            done
            
            echo "Found ${#pkg_names[@]} pinned packages:"
            for idx in "${!pkg_names[@]}"; do
              echo "  - ${pkg_names[$idx]} (current: ${current_versions[$idx]})"
            done
            
            # Query the package repository for available versions in a single container run
            available_output=$(docker run --rm "$base_image" sh -c '
              set -e
              apt-get update -qq 2>/dev/null
              for pkg in "$@"; do
                candidate=$(
                  apt-cache policy "$pkg" 2>/dev/null | \
                  grep -A1 "Candidate:" | \
                  tail -1 | \
                  awk "{print \$2}"
                )
                echo "${candidate}"
              done
            ' sh "${pkg_names[@]}" || echo "")
            
            # Read available versions into an array, preserving order
            IFS=$'\n' read -r -d '' -a available_versions < <(printf '%s\0' $available_output || printf '\0')
            
            # Compare current and available versions
            for idx in "${!pkg_names[@]}"; do
              pkg_name=${pkg_names[$idx]}
              current_version=${current_versions[$idx]}
              available="${available_versions[$idx]}"
              
              echo "Checking $pkg_name (current: $current_version)..."
              
              if [ -z "$available" ]; then
                results="${results}\n- **$pkg_name**: Could not determine available version"
                continue
              fi
              
              if [ "$current_version" != "$available" ]; then
                results="${results}\n- **$pkg_name**: $current_version â†’ $available"
                echo "  Update available: $current_version â†’ $available"
              else
                echo "  Up to date"
              fi
            done
            
            echo "$results"
          }
          
          # Build the custom base image used by the devcontainer so we check against the correct repositories
          docker build -t ghcr.io/jhulten/toolbox/base:local base
          
          # Check base Dockerfile (still uses debian:13-slim directly)
          base_results=$(check_dockerfile "base/Dockerfile" "debian:13-slim")
          
          # Check devcontainer Dockerfile against the locally built custom base image
          devcontainer_results=$(check_dockerfile "devcontainer/Dockerfile" "ghcr.io/jhulten/toolbox/base:local")
          
          # Combine results
          all_results=""
          if [ -n "$base_results" ]; then
            all_results="${all_results}### base/Dockerfile\n${base_results}\n"
          fi
          if [ -n "$devcontainer_results" ]; then
            all_results="${all_results}\n### devcontainer/Dockerfile\n${devcontainer_results}\n"
          fi
          
          # Save results to file and output
          if [ -n "$all_results" ]; then
            echo "updates_found=true" >> $GITHUB_OUTPUT
            echo "$all_results" > /tmp/update_results.txt
            echo "RESULTS<<EOF" >> $GITHUB_ENV
            echo -e "$all_results" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
          else
            echo "updates_found=false" >> $GITHUB_OUTPUT
            echo "No updates found for any packages."
          fi

      - name: Create or update issue
        if: steps.check.outputs.updates_found == 'true'
        uses: actions/github-script@v7
        env:
          RESULTS: ${{ env.RESULTS }}
        with:
          script: |
            const results = process.env.RESULTS;
            const title = 'ðŸ“¦ APT Package Updates Available';
            const body = `# APT Package Updates Available
            
            The following pinned APT packages have newer versions available:
            
            ${results}
            
            ## Action Required
            
            Please review these updates and update the Dockerfiles accordingly. Consider:
            1. Testing the new versions in a development environment
            2. Checking for breaking changes in package changelogs
            3. Updating the pinned versions in the Dockerfiles
            4. Running build workflows to verify compatibility
            
            ---
            *This issue was automatically generated by the \`check-apt-updates\` workflow.*
            *Last checked: ${new Date().toISOString()}*`;
            
            // Search for existing open issue (paginate through all matching issues)
            let existingIssue = null;
            let page = 1;
            const perPage = 100;
            while (!existingIssue) {
              const issuesPage = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                labels: ['apt-updates'],
                per_page: perPage,
                page: page
              });
              
              existingIssue = issuesPage.data.find(issue => issue.title === title) || null;
              
              // If fewer issues than perPage were returned, we've reached the last page
              if (existingIssue || issuesPage.data.length < perPage) {
                break;
              }
              
              page += 1;
            }
            
            if (existingIssue) {
              // Update existing issue
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existingIssue.number,
                body: body
              });
              console.log(`Updated existing issue #${existingIssue.number}`);
            } else {
              // Create new issue
              const issue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body,
                labels: ['apt-updates', 'dependencies']
              });
              console.log(`Created new issue #${issue.data.number}`);
            }

      - name: Report no updates
        if: steps.check.outputs.updates_found == 'false'
        run: |
          echo "âœ… All pinned APT packages are up to date!"
